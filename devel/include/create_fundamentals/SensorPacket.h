// Generated by gencpp from file create_fundamentals/SensorPacket.msg
// DO NOT EDIT!


#ifndef CREATE_FUNDAMENTALS_MESSAGE_SENSORPACKET_H
#define CREATE_FUNDAMENTALS_MESSAGE_SENSORPACKET_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace create_fundamentals
{
template <class ContainerAllocator>
struct SensorPacket_
{
  typedef SensorPacket_<ContainerAllocator> Type;

  SensorPacket_()
    : header()
    , wheeldropCaster(false)
    , wheeldropLeft(false)
    , wheeldropRight(false)
    , bumpLeft(false)
    , bumpRight(false)
    , wall(false)
    , cliffLeft(false)
    , cliffFronLeft(false)
    , cliffFrontRight(false)
    , cliffRight(false)
    , virtualWall(false)
    , infraredByte(0)
    , advance(false)
    , play(false)
    , encoderLeft(0.0)
    , encoderRight(0.0)
    , chargingState(0)
    , voltage(0)
    , current(0)
    , batteryTemperature(0)
    , batteryCharge(0)
    , batteryCapacity(0)
    , wallSignal(0)
    , cliffLeftSignal(0)
    , cliffFrontLeftSignal(0)
    , cliffFrontRightSignal(0)
    , cliffRightSignal(0)
    , homeBase(false)
    , internalCharger(false)
    , songNumber(0)
    , songPlaying(0)  {
    }
  SensorPacket_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , wheeldropCaster(false)
    , wheeldropLeft(false)
    , wheeldropRight(false)
    , bumpLeft(false)
    , bumpRight(false)
    , wall(false)
    , cliffLeft(false)
    , cliffFronLeft(false)
    , cliffFrontRight(false)
    , cliffRight(false)
    , virtualWall(false)
    , infraredByte(0)
    , advance(false)
    , play(false)
    , encoderLeft(0.0)
    , encoderRight(0.0)
    , chargingState(0)
    , voltage(0)
    , current(0)
    , batteryTemperature(0)
    , batteryCharge(0)
    , batteryCapacity(0)
    , wallSignal(0)
    , cliffLeftSignal(0)
    , cliffFrontLeftSignal(0)
    , cliffFrontRightSignal(0)
    , cliffRightSignal(0)
    , homeBase(false)
    , internalCharger(false)
    , songNumber(0)
    , songPlaying(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint8_t _wheeldropCaster_type;
  _wheeldropCaster_type wheeldropCaster;

   typedef uint8_t _wheeldropLeft_type;
  _wheeldropLeft_type wheeldropLeft;

   typedef uint8_t _wheeldropRight_type;
  _wheeldropRight_type wheeldropRight;

   typedef uint8_t _bumpLeft_type;
  _bumpLeft_type bumpLeft;

   typedef uint8_t _bumpRight_type;
  _bumpRight_type bumpRight;

   typedef uint8_t _wall_type;
  _wall_type wall;

   typedef uint8_t _cliffLeft_type;
  _cliffLeft_type cliffLeft;

   typedef uint8_t _cliffFronLeft_type;
  _cliffFronLeft_type cliffFronLeft;

   typedef uint8_t _cliffFrontRight_type;
  _cliffFrontRight_type cliffFrontRight;

   typedef uint8_t _cliffRight_type;
  _cliffRight_type cliffRight;

   typedef uint8_t _virtualWall_type;
  _virtualWall_type virtualWall;

   typedef uint8_t _infraredByte_type;
  _infraredByte_type infraredByte;

   typedef uint8_t _advance_type;
  _advance_type advance;

   typedef uint8_t _play_type;
  _play_type play;

   typedef float _encoderLeft_type;
  _encoderLeft_type encoderLeft;

   typedef float _encoderRight_type;
  _encoderRight_type encoderRight;

   typedef uint8_t _chargingState_type;
  _chargingState_type chargingState;

   typedef uint16_t _voltage_type;
  _voltage_type voltage;

   typedef int16_t _current_type;
  _current_type current;

   typedef int8_t _batteryTemperature_type;
  _batteryTemperature_type batteryTemperature;

   typedef uint16_t _batteryCharge_type;
  _batteryCharge_type batteryCharge;

   typedef uint16_t _batteryCapacity_type;
  _batteryCapacity_type batteryCapacity;

   typedef uint16_t _wallSignal_type;
  _wallSignal_type wallSignal;

   typedef uint16_t _cliffLeftSignal_type;
  _cliffLeftSignal_type cliffLeftSignal;

   typedef uint16_t _cliffFrontLeftSignal_type;
  _cliffFrontLeftSignal_type cliffFrontLeftSignal;

   typedef uint16_t _cliffFrontRightSignal_type;
  _cliffFrontRightSignal_type cliffFrontRightSignal;

   typedef uint16_t _cliffRightSignal_type;
  _cliffRightSignal_type cliffRightSignal;

   typedef uint8_t _homeBase_type;
  _homeBase_type homeBase;

   typedef uint8_t _internalCharger_type;
  _internalCharger_type internalCharger;

   typedef uint8_t _songNumber_type;
  _songNumber_type songNumber;

   typedef uint8_t _songPlaying_type;
  _songPlaying_type songPlaying;





  typedef boost::shared_ptr< ::create_fundamentals::SensorPacket_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::create_fundamentals::SensorPacket_<ContainerAllocator> const> ConstPtr;

}; // struct SensorPacket_

typedef ::create_fundamentals::SensorPacket_<std::allocator<void> > SensorPacket;

typedef boost::shared_ptr< ::create_fundamentals::SensorPacket > SensorPacketPtr;
typedef boost::shared_ptr< ::create_fundamentals::SensorPacket const> SensorPacketConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::create_fundamentals::SensorPacket_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::create_fundamentals::SensorPacket_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::create_fundamentals::SensorPacket_<ContainerAllocator1> & lhs, const ::create_fundamentals::SensorPacket_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.wheeldropCaster == rhs.wheeldropCaster &&
    lhs.wheeldropLeft == rhs.wheeldropLeft &&
    lhs.wheeldropRight == rhs.wheeldropRight &&
    lhs.bumpLeft == rhs.bumpLeft &&
    lhs.bumpRight == rhs.bumpRight &&
    lhs.wall == rhs.wall &&
    lhs.cliffLeft == rhs.cliffLeft &&
    lhs.cliffFronLeft == rhs.cliffFronLeft &&
    lhs.cliffFrontRight == rhs.cliffFrontRight &&
    lhs.cliffRight == rhs.cliffRight &&
    lhs.virtualWall == rhs.virtualWall &&
    lhs.infraredByte == rhs.infraredByte &&
    lhs.advance == rhs.advance &&
    lhs.play == rhs.play &&
    lhs.encoderLeft == rhs.encoderLeft &&
    lhs.encoderRight == rhs.encoderRight &&
    lhs.chargingState == rhs.chargingState &&
    lhs.voltage == rhs.voltage &&
    lhs.current == rhs.current &&
    lhs.batteryTemperature == rhs.batteryTemperature &&
    lhs.batteryCharge == rhs.batteryCharge &&
    lhs.batteryCapacity == rhs.batteryCapacity &&
    lhs.wallSignal == rhs.wallSignal &&
    lhs.cliffLeftSignal == rhs.cliffLeftSignal &&
    lhs.cliffFrontLeftSignal == rhs.cliffFrontLeftSignal &&
    lhs.cliffFrontRightSignal == rhs.cliffFrontRightSignal &&
    lhs.cliffRightSignal == rhs.cliffRightSignal &&
    lhs.homeBase == rhs.homeBase &&
    lhs.internalCharger == rhs.internalCharger &&
    lhs.songNumber == rhs.songNumber &&
    lhs.songPlaying == rhs.songPlaying;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::create_fundamentals::SensorPacket_<ContainerAllocator1> & lhs, const ::create_fundamentals::SensorPacket_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace create_fundamentals

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::create_fundamentals::SensorPacket_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::create_fundamentals::SensorPacket_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::create_fundamentals::SensorPacket_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::create_fundamentals::SensorPacket_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::create_fundamentals::SensorPacket_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::create_fundamentals::SensorPacket_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::create_fundamentals::SensorPacket_<ContainerAllocator> >
{
  static const char* value()
  {
    return "6107c4dd98a9eb48e0898ce64bfb3dc6";
  }

  static const char* value(const ::create_fundamentals::SensorPacket_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x6107c4dd98a9eb48ULL;
  static const uint64_t static_value2 = 0xe0898ce64bfb3dc6ULL;
};

template<class ContainerAllocator>
struct DataType< ::create_fundamentals::SensorPacket_<ContainerAllocator> >
{
  static const char* value()
  {
    return "create_fundamentals/SensorPacket";
  }

  static const char* value(const ::create_fundamentals::SensorPacket_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::create_fundamentals::SensorPacket_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"bool wheeldropCaster\n"
"bool wheeldropLeft\n"
"bool wheeldropRight\n"
"bool bumpLeft\n"
"bool bumpRight\n"
"bool wall\n"
"bool cliffLeft\n"
"bool cliffFronLeft\n"
"bool cliffFrontRight\n"
"bool cliffRight\n"
"bool virtualWall\n"
"uint8 infraredByte\n"
"bool advance\n"
"bool play\n"
"float32 encoderLeft\n"
"float32 encoderRight\n"
"uint8 chargingState\n"
"uint16 voltage\n"
"int16 current\n"
"int8 batteryTemperature\n"
"uint16 batteryCharge\n"
"uint16 batteryCapacity\n"
"uint16 wallSignal\n"
"uint16 cliffLeftSignal\n"
"uint16 cliffFrontLeftSignal\n"
"uint16 cliffFrontRightSignal\n"
"uint16 cliffRightSignal\n"
"bool homeBase\n"
"bool internalCharger\n"
"uint8 songNumber\n"
"uint8 songPlaying\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::create_fundamentals::SensorPacket_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::create_fundamentals::SensorPacket_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.wheeldropCaster);
      stream.next(m.wheeldropLeft);
      stream.next(m.wheeldropRight);
      stream.next(m.bumpLeft);
      stream.next(m.bumpRight);
      stream.next(m.wall);
      stream.next(m.cliffLeft);
      stream.next(m.cliffFronLeft);
      stream.next(m.cliffFrontRight);
      stream.next(m.cliffRight);
      stream.next(m.virtualWall);
      stream.next(m.infraredByte);
      stream.next(m.advance);
      stream.next(m.play);
      stream.next(m.encoderLeft);
      stream.next(m.encoderRight);
      stream.next(m.chargingState);
      stream.next(m.voltage);
      stream.next(m.current);
      stream.next(m.batteryTemperature);
      stream.next(m.batteryCharge);
      stream.next(m.batteryCapacity);
      stream.next(m.wallSignal);
      stream.next(m.cliffLeftSignal);
      stream.next(m.cliffFrontLeftSignal);
      stream.next(m.cliffFrontRightSignal);
      stream.next(m.cliffRightSignal);
      stream.next(m.homeBase);
      stream.next(m.internalCharger);
      stream.next(m.songNumber);
      stream.next(m.songPlaying);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SensorPacket_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::create_fundamentals::SensorPacket_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::create_fundamentals::SensorPacket_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "wheeldropCaster: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.wheeldropCaster);
    s << indent << "wheeldropLeft: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.wheeldropLeft);
    s << indent << "wheeldropRight: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.wheeldropRight);
    s << indent << "bumpLeft: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bumpLeft);
    s << indent << "bumpRight: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bumpRight);
    s << indent << "wall: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.wall);
    s << indent << "cliffLeft: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cliffLeft);
    s << indent << "cliffFronLeft: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cliffFronLeft);
    s << indent << "cliffFrontRight: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cliffFrontRight);
    s << indent << "cliffRight: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cliffRight);
    s << indent << "virtualWall: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.virtualWall);
    s << indent << "infraredByte: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.infraredByte);
    s << indent << "advance: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.advance);
    s << indent << "play: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.play);
    s << indent << "encoderLeft: ";
    Printer<float>::stream(s, indent + "  ", v.encoderLeft);
    s << indent << "encoderRight: ";
    Printer<float>::stream(s, indent + "  ", v.encoderRight);
    s << indent << "chargingState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.chargingState);
    s << indent << "voltage: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.voltage);
    s << indent << "current: ";
    Printer<int16_t>::stream(s, indent + "  ", v.current);
    s << indent << "batteryTemperature: ";
    Printer<int8_t>::stream(s, indent + "  ", v.batteryTemperature);
    s << indent << "batteryCharge: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.batteryCharge);
    s << indent << "batteryCapacity: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.batteryCapacity);
    s << indent << "wallSignal: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.wallSignal);
    s << indent << "cliffLeftSignal: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.cliffLeftSignal);
    s << indent << "cliffFrontLeftSignal: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.cliffFrontLeftSignal);
    s << indent << "cliffFrontRightSignal: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.cliffFrontRightSignal);
    s << indent << "cliffRightSignal: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.cliffRightSignal);
    s << indent << "homeBase: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.homeBase);
    s << indent << "internalCharger: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.internalCharger);
    s << indent << "songNumber: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.songNumber);
    s << indent << "songPlaying: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.songPlaying);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CREATE_FUNDAMENTALS_MESSAGE_SENSORPACKET_H
